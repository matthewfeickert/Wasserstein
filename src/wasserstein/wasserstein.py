# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.


import numpy as np
import itertools



from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _wasserstein
else:
    import _wasserstein

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _wasserstein.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _wasserstein.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _wasserstein.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _wasserstein.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _wasserstein.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _wasserstein.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _wasserstein.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _wasserstein.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _wasserstein.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _wasserstein.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _wasserstein.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _wasserstein.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _wasserstein.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _wasserstein.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _wasserstein.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _wasserstein.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _wasserstein.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _wasserstein:
_wasserstein.SwigPyIterator_swigregister(SwigPyIterator)
class vectorDouble(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vectorDouble self) -> SwigPyIterator"""
        return _wasserstein.vectorDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vectorDouble self) -> bool"""
        return _wasserstein.vectorDouble___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vectorDouble self) -> bool"""
        return _wasserstein.vectorDouble___bool__(self)

    def __len__(self):
        r"""__len__(vectorDouble self) -> std::vector< double >::size_type"""
        return _wasserstein.vectorDouble___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> vectorDouble"""
        return _wasserstein.vectorDouble___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(vectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, vectorDouble v)
        """
        return _wasserstein.vectorDouble___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _wasserstein.vectorDouble___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vectorDouble self, std::vector< double >::difference_type i)
        __delitem__(vectorDouble self, SWIGPY_SLICEOBJECT * slice)
        """
        return _wasserstein.vectorDouble___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vectorDouble self, SWIGPY_SLICEOBJECT * slice) -> vectorDouble
        __getitem__(vectorDouble self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _wasserstein.vectorDouble___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vectorDouble self, SWIGPY_SLICEOBJECT * slice, vectorDouble v)
        __setitem__(vectorDouble self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vectorDouble self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _wasserstein.vectorDouble___setitem__(self, *args)

    def pop(self):
        r"""pop(vectorDouble self) -> std::vector< double >::value_type"""
        return _wasserstein.vectorDouble_pop(self)

    def append(self, x):
        r"""append(vectorDouble self, std::vector< double >::value_type const & x)"""
        return _wasserstein.vectorDouble_append(self, x)

    def empty(self):
        r"""empty(vectorDouble self) -> bool"""
        return _wasserstein.vectorDouble_empty(self)

    def size(self):
        r"""size(vectorDouble self) -> std::vector< double >::size_type"""
        return _wasserstein.vectorDouble_size(self)

    def swap(self, v):
        r"""swap(vectorDouble self, vectorDouble v)"""
        return _wasserstein.vectorDouble_swap(self, v)

    def begin(self):
        r"""begin(vectorDouble self) -> std::vector< double >::iterator"""
        return _wasserstein.vectorDouble_begin(self)

    def end(self):
        r"""end(vectorDouble self) -> std::vector< double >::iterator"""
        return _wasserstein.vectorDouble_end(self)

    def rbegin(self):
        r"""rbegin(vectorDouble self) -> std::vector< double >::reverse_iterator"""
        return _wasserstein.vectorDouble_rbegin(self)

    def rend(self):
        r"""rend(vectorDouble self) -> std::vector< double >::reverse_iterator"""
        return _wasserstein.vectorDouble_rend(self)

    def clear(self):
        r"""clear(vectorDouble self)"""
        return _wasserstein.vectorDouble_clear(self)

    def get_allocator(self):
        r"""get_allocator(vectorDouble self) -> std::vector< double >::allocator_type"""
        return _wasserstein.vectorDouble_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vectorDouble self)"""
        return _wasserstein.vectorDouble_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vectorDouble self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(vectorDouble self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _wasserstein.vectorDouble_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vectorDouble self) -> vectorDouble
        __init__(vectorDouble self, vectorDouble other) -> vectorDouble
        __init__(vectorDouble self, std::vector< double >::size_type size) -> vectorDouble
        __init__(vectorDouble self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> vectorDouble
        """
        _wasserstein.vectorDouble_swiginit(self, _wasserstein.new_vectorDouble(*args))

    def push_back(self, x):
        r"""push_back(vectorDouble self, std::vector< double >::value_type const & x)"""
        return _wasserstein.vectorDouble_push_back(self, x)

    def front(self):
        r"""front(vectorDouble self) -> std::vector< double >::value_type const &"""
        return _wasserstein.vectorDouble_front(self)

    def back(self):
        r"""back(vectorDouble self) -> std::vector< double >::value_type const &"""
        return _wasserstein.vectorDouble_back(self)

    def assign(self, n, x):
        r"""assign(vectorDouble self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _wasserstein.vectorDouble_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vectorDouble self, std::vector< double >::size_type new_size)
        resize(vectorDouble self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _wasserstein.vectorDouble_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vectorDouble self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(vectorDouble self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _wasserstein.vectorDouble_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vectorDouble self, std::vector< double >::size_type n)"""
        return _wasserstein.vectorDouble_reserve(self, n)

    def capacity(self):
        r"""capacity(vectorDouble self) -> std::vector< double >::size_type"""
        return _wasserstein.vectorDouble_capacity(self)
    __swig_destroy__ = _wasserstein.delete_vectorDouble

# Register vectorDouble in _wasserstein:
_wasserstein.vectorDouble_swigregister(vectorDouble)
class vectorString(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vectorString self) -> SwigPyIterator"""
        return _wasserstein.vectorString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vectorString self) -> bool"""
        return _wasserstein.vectorString___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vectorString self) -> bool"""
        return _wasserstein.vectorString___bool__(self)

    def __len__(self):
        r"""__len__(vectorString self) -> std::vector< std::string >::size_type"""
        return _wasserstein.vectorString___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> vectorString"""
        return _wasserstein.vectorString___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(vectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, vectorString v)
        """
        return _wasserstein.vectorString___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _wasserstein.vectorString___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vectorString self, std::vector< std::string >::difference_type i)
        __delitem__(vectorString self, SWIGPY_SLICEOBJECT * slice)
        """
        return _wasserstein.vectorString___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vectorString self, SWIGPY_SLICEOBJECT * slice) -> vectorString
        __getitem__(vectorString self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _wasserstein.vectorString___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vectorString self, SWIGPY_SLICEOBJECT * slice, vectorString v)
        __setitem__(vectorString self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _wasserstein.vectorString___setitem__(self, *args)

    def pop(self):
        r"""pop(vectorString self) -> std::vector< std::string >::value_type"""
        return _wasserstein.vectorString_pop(self)

    def append(self, x):
        r"""append(vectorString self, std::vector< std::string >::value_type const & x)"""
        return _wasserstein.vectorString_append(self, x)

    def empty(self):
        r"""empty(vectorString self) -> bool"""
        return _wasserstein.vectorString_empty(self)

    def size(self):
        r"""size(vectorString self) -> std::vector< std::string >::size_type"""
        return _wasserstein.vectorString_size(self)

    def swap(self, v):
        r"""swap(vectorString self, vectorString v)"""
        return _wasserstein.vectorString_swap(self, v)

    def begin(self):
        r"""begin(vectorString self) -> std::vector< std::string >::iterator"""
        return _wasserstein.vectorString_begin(self)

    def end(self):
        r"""end(vectorString self) -> std::vector< std::string >::iterator"""
        return _wasserstein.vectorString_end(self)

    def rbegin(self):
        r"""rbegin(vectorString self) -> std::vector< std::string >::reverse_iterator"""
        return _wasserstein.vectorString_rbegin(self)

    def rend(self):
        r"""rend(vectorString self) -> std::vector< std::string >::reverse_iterator"""
        return _wasserstein.vectorString_rend(self)

    def clear(self):
        r"""clear(vectorString self)"""
        return _wasserstein.vectorString_clear(self)

    def get_allocator(self):
        r"""get_allocator(vectorString self) -> std::vector< std::string >::allocator_type"""
        return _wasserstein.vectorString_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vectorString self)"""
        return _wasserstein.vectorString_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vectorString self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(vectorString self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _wasserstein.vectorString_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vectorString self) -> vectorString
        __init__(vectorString self, vectorString other) -> vectorString
        __init__(vectorString self, std::vector< std::string >::size_type size) -> vectorString
        __init__(vectorString self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vectorString
        """
        _wasserstein.vectorString_swiginit(self, _wasserstein.new_vectorString(*args))

    def push_back(self, x):
        r"""push_back(vectorString self, std::vector< std::string >::value_type const & x)"""
        return _wasserstein.vectorString_push_back(self, x)

    def front(self):
        r"""front(vectorString self) -> std::vector< std::string >::value_type const &"""
        return _wasserstein.vectorString_front(self)

    def back(self):
        r"""back(vectorString self) -> std::vector< std::string >::value_type const &"""
        return _wasserstein.vectorString_back(self)

    def assign(self, n, x):
        r"""assign(vectorString self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _wasserstein.vectorString_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vectorString self, std::vector< std::string >::size_type new_size)
        resize(vectorString self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _wasserstein.vectorString_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vectorString self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(vectorString self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _wasserstein.vectorString_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vectorString self, std::vector< std::string >::size_type n)"""
        return _wasserstein.vectorString_reserve(self, n)

    def capacity(self):
        r"""capacity(vectorString self) -> std::vector< std::string >::size_type"""
        return _wasserstein.vectorString_capacity(self)
    __swig_destroy__ = _wasserstein.delete_vectorString

# Register vectorString in _wasserstein:
_wasserstein.vectorString_swigregister(vectorString)
class pairVectorDouble(object):
    r"""Proxy of C++ std::pair< std::vector< double >,std::vector< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(pairVectorDouble self) -> pairVectorDouble
        __init__(pairVectorDouble self, vectorDouble first, vectorDouble second) -> pairVectorDouble
        __init__(pairVectorDouble self, pairVectorDouble other) -> pairVectorDouble
        """
        _wasserstein.pairVectorDouble_swiginit(self, _wasserstein.new_pairVectorDouble(*args))
    first = property(_wasserstein.pairVectorDouble_first_get, _wasserstein.pairVectorDouble_first_set, doc=r"""first : std::vector<(double,std::allocator<(double)>)>""")
    second = property(_wasserstein.pairVectorDouble_second_get, _wasserstein.pairVectorDouble_second_set, doc=r"""second : std::vector<(double,std::allocator<(double)>)>""")
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index):
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _wasserstein.delete_pairVectorDouble

# Register pairVectorDouble in _wasserstein:
_wasserstein.pairVectorDouble_swigregister(pairVectorDouble)
class vectorFloat(object):
    r"""Proxy of C++ std::vector< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vectorFloat self) -> SwigPyIterator"""
        return _wasserstein.vectorFloat_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vectorFloat self) -> bool"""
        return _wasserstein.vectorFloat___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vectorFloat self) -> bool"""
        return _wasserstein.vectorFloat___bool__(self)

    def __len__(self):
        r"""__len__(vectorFloat self) -> std::vector< float >::size_type"""
        return _wasserstein.vectorFloat___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> vectorFloat"""
        return _wasserstein.vectorFloat___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        __setslice__(vectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, vectorFloat v)
        """
        return _wasserstein.vectorFloat___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _wasserstein.vectorFloat___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vectorFloat self, std::vector< float >::difference_type i)
        __delitem__(vectorFloat self, SWIGPY_SLICEOBJECT * slice)
        """
        return _wasserstein.vectorFloat___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vectorFloat self, SWIGPY_SLICEOBJECT * slice) -> vectorFloat
        __getitem__(vectorFloat self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _wasserstein.vectorFloat___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vectorFloat self, SWIGPY_SLICEOBJECT * slice, vectorFloat v)
        __setitem__(vectorFloat self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vectorFloat self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _wasserstein.vectorFloat___setitem__(self, *args)

    def pop(self):
        r"""pop(vectorFloat self) -> std::vector< float >::value_type"""
        return _wasserstein.vectorFloat_pop(self)

    def append(self, x):
        r"""append(vectorFloat self, std::vector< float >::value_type const & x)"""
        return _wasserstein.vectorFloat_append(self, x)

    def empty(self):
        r"""empty(vectorFloat self) -> bool"""
        return _wasserstein.vectorFloat_empty(self)

    def size(self):
        r"""size(vectorFloat self) -> std::vector< float >::size_type"""
        return _wasserstein.vectorFloat_size(self)

    def swap(self, v):
        r"""swap(vectorFloat self, vectorFloat v)"""
        return _wasserstein.vectorFloat_swap(self, v)

    def begin(self):
        r"""begin(vectorFloat self) -> std::vector< float >::iterator"""
        return _wasserstein.vectorFloat_begin(self)

    def end(self):
        r"""end(vectorFloat self) -> std::vector< float >::iterator"""
        return _wasserstein.vectorFloat_end(self)

    def rbegin(self):
        r"""rbegin(vectorFloat self) -> std::vector< float >::reverse_iterator"""
        return _wasserstein.vectorFloat_rbegin(self)

    def rend(self):
        r"""rend(vectorFloat self) -> std::vector< float >::reverse_iterator"""
        return _wasserstein.vectorFloat_rend(self)

    def clear(self):
        r"""clear(vectorFloat self)"""
        return _wasserstein.vectorFloat_clear(self)

    def get_allocator(self):
        r"""get_allocator(vectorFloat self) -> std::vector< float >::allocator_type"""
        return _wasserstein.vectorFloat_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vectorFloat self)"""
        return _wasserstein.vectorFloat_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vectorFloat self, std::vector< float >::iterator pos) -> std::vector< float >::iterator
        erase(vectorFloat self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator
        """
        return _wasserstein.vectorFloat_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vectorFloat self) -> vectorFloat
        __init__(vectorFloat self, vectorFloat other) -> vectorFloat
        __init__(vectorFloat self, std::vector< float >::size_type size) -> vectorFloat
        __init__(vectorFloat self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> vectorFloat
        """
        _wasserstein.vectorFloat_swiginit(self, _wasserstein.new_vectorFloat(*args))

    def push_back(self, x):
        r"""push_back(vectorFloat self, std::vector< float >::value_type const & x)"""
        return _wasserstein.vectorFloat_push_back(self, x)

    def front(self):
        r"""front(vectorFloat self) -> std::vector< float >::value_type const &"""
        return _wasserstein.vectorFloat_front(self)

    def back(self):
        r"""back(vectorFloat self) -> std::vector< float >::value_type const &"""
        return _wasserstein.vectorFloat_back(self)

    def assign(self, n, x):
        r"""assign(vectorFloat self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)"""
        return _wasserstein.vectorFloat_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vectorFloat self, std::vector< float >::size_type new_size)
        resize(vectorFloat self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)
        """
        return _wasserstein.vectorFloat_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vectorFloat self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator
        insert(vectorFloat self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)
        """
        return _wasserstein.vectorFloat_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vectorFloat self, std::vector< float >::size_type n)"""
        return _wasserstein.vectorFloat_reserve(self, n)

    def capacity(self):
        r"""capacity(vectorFloat self) -> std::vector< float >::size_type"""
        return _wasserstein.vectorFloat_capacity(self)
    __swig_destroy__ = _wasserstein.delete_vectorFloat

# Register vectorFloat in _wasserstein:
_wasserstein.vectorFloat_swigregister(vectorFloat)
class pairVectorFloat(object):
    r"""Proxy of C++ std::pair< std::vector< float >,std::vector< float > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(pairVectorFloat self) -> pairVectorFloat
        __init__(pairVectorFloat self, vectorFloat first, vectorFloat second) -> pairVectorFloat
        __init__(pairVectorFloat self, pairVectorFloat other) -> pairVectorFloat
        """
        _wasserstein.pairVectorFloat_swiginit(self, _wasserstein.new_pairVectorFloat(*args))
    first = property(_wasserstein.pairVectorFloat_first_get, _wasserstein.pairVectorFloat_first_set, doc=r"""first : std::vector<(float,std::allocator<(float)>)>""")
    second = property(_wasserstein.pairVectorFloat_second_get, _wasserstein.pairVectorFloat_second_set, doc=r"""second : std::vector<(float,std::allocator<(float)>)>""")
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index):
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _wasserstein.delete_pairVectorFloat

# Register pairVectorFloat in _wasserstein:
_wasserstein.pairVectorFloat_swigregister(pairVectorFloat)
EMDStatus_Success = _wasserstein.EMDStatus_Success

EMDStatus_Empty = _wasserstein.EMDStatus_Empty

EMDStatus_SupplyMismatch = _wasserstein.EMDStatus_SupplyMismatch

EMDStatus_Unbounded = _wasserstein.EMDStatus_Unbounded

EMDStatus_MaxIterReached = _wasserstein.EMDStatus_MaxIterReached

EMDStatus_Infeasible = _wasserstein.EMDStatus_Infeasible

ExtraParticle_Neither = _wasserstein.ExtraParticle_Neither

ExtraParticle_Zero = _wasserstein.ExtraParticle_Zero

ExtraParticle_One = _wasserstein.ExtraParticle_One

EMDPairsStorage_Full = _wasserstein.EMDPairsStorage_Full

EMDPairsStorage_FullSymmetric = _wasserstein.EMDPairsStorage_FullSymmetric

EMDPairsStorage_FlattenedSymmetric = _wasserstein.EMDPairsStorage_FlattenedSymmetric

EMDPairsStorage_External = _wasserstein.EMDPairsStorage_External


def check_emd_status(status):
    r"""check_emd_status(wasserstein::EMDStatus status)"""
    return _wasserstein.check_emd_status(status)
class EMDBaseFloat64(object):
    r"""Proxy of C++ wasserstein::EMDBase< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _wasserstein.delete_EMDBaseFloat64

    def R(self):
        r"""R(EMDBaseFloat64 self) -> double"""
        return _wasserstein.EMDBaseFloat64_R(self)

    def beta(self):
        r"""beta(EMDBaseFloat64 self) -> double"""
        return _wasserstein.EMDBaseFloat64_beta(self)

    def set_R(self, R):
        r"""set_R(EMDBaseFloat64 self, double R)"""
        return _wasserstein.EMDBaseFloat64_set_R(self, R)

    def set_beta(self, beta):
        r"""set_beta(EMDBaseFloat64 self, double beta)"""
        return _wasserstein.EMDBaseFloat64_set_beta(self, beta)

    def set_network_simplex_params(self, n_iter_max=100000, epsilon_large_factor=1000, epsilon_small_factor=1):
        r"""set_network_simplex_params(EMDBaseFloat64 self, std::size_t n_iter_max=100000, double epsilon_large_factor=1000, double epsilon_small_factor=1)"""
        return _wasserstein.EMDBaseFloat64_set_network_simplex_params(self, n_iter_max, epsilon_large_factor, epsilon_small_factor)

    def norm(self):
        r"""norm(EMDBaseFloat64 self) -> bool"""
        return _wasserstein.EMDBaseFloat64_norm(self)

    def set_norm(self, norm):
        r"""set_norm(EMDBaseFloat64 self, bool norm)"""
        return _wasserstein.EMDBaseFloat64_set_norm(self, norm)

    def do_timing(self):
        r"""do_timing(EMDBaseFloat64 self) -> bool"""
        return _wasserstein.EMDBaseFloat64_do_timing(self)

    def set_do_timing(self, timing):
        r"""set_do_timing(EMDBaseFloat64 self, bool timing)"""
        return _wasserstein.EMDBaseFloat64_set_do_timing(self, timing)

    def external_dists(self):
        r"""external_dists(EMDBaseFloat64 self) -> bool"""
        return _wasserstein.EMDBaseFloat64_external_dists(self)

    def set_external_dists(self, exdists):
        r"""set_external_dists(EMDBaseFloat64 self, bool exdists)"""
        return _wasserstein.EMDBaseFloat64_set_external_dists(self, exdists)

    def n0(self):
        r"""n0(EMDBaseFloat64 self) -> wasserstein::index_type"""
        return _wasserstein.EMDBaseFloat64_n0(self)

    def n1(self):
        r"""n1(EMDBaseFloat64 self) -> wasserstein::index_type"""
        return _wasserstein.EMDBaseFloat64_n1(self)

    def extra(self):
        r"""extra(EMDBaseFloat64 self) -> wasserstein::ExtraParticle"""
        return _wasserstein.EMDBaseFloat64_extra(self)

    def emd(self):
        r"""emd(EMDBaseFloat64 self) -> double"""
        return _wasserstein.EMDBaseFloat64_emd(self)

    def status(self):
        r"""status(EMDBaseFloat64 self) -> wasserstein::EMDStatus"""
        return _wasserstein.EMDBaseFloat64_status(self)

    def weightdiff(self):
        r"""weightdiff(EMDBaseFloat64 self) -> double"""
        return _wasserstein.EMDBaseFloat64_weightdiff(self)

    def scale(self):
        r"""scale(EMDBaseFloat64 self) -> double"""
        return _wasserstein.EMDBaseFloat64_scale(self)

    def n_iter(self):
        r"""n_iter(EMDBaseFloat64 self) -> std::size_t"""
        return _wasserstein.EMDBaseFloat64_n_iter(self)

    def dists_vec(self):
        r"""dists_vec(EMDBaseFloat64 self) -> vectorDouble"""
        return _wasserstein.EMDBaseFloat64_dists_vec(self)

    def flows_vec(self):
        r"""flows_vec(EMDBaseFloat64 self) -> vectorDouble"""
        return _wasserstein.EMDBaseFloat64_flows_vec(self)

    def flow(self, *args):
        r"""
        flow(EMDBaseFloat64 self, wasserstein::index_type i, wasserstein::index_type j) -> double
        flow(EMDBaseFloat64 self, std::size_t ind) -> double
        """
        return _wasserstein.EMDBaseFloat64_flow(self, *args)

    def node_potentials(self):
        r"""node_potentials(EMDBaseFloat64 self) -> pairVectorDouble"""
        return _wasserstein.EMDBaseFloat64_node_potentials(self)

    def duration(self):
        r"""duration(EMDBaseFloat64 self) -> double"""
        return _wasserstein.EMDBaseFloat64_duration(self)

    def clear(self):
        r"""clear(EMDBaseFloat64 self)"""
        return _wasserstein.EMDBaseFloat64_clear(self)

    def flows(self):
        r"""flows(EMDBaseFloat64 self)"""
        return _wasserstein.EMDBaseFloat64_flows(self)

    def dists(self):
        r"""dists(EMDBaseFloat64 self)"""
        return _wasserstein.EMDBaseFloat64_dists(self)

    def npy_node_potentials(self):
        r"""npy_node_potentials(EMDBaseFloat64 self)"""
        return _wasserstein.EMDBaseFloat64_npy_node_potentials(self)

# Register EMDBaseFloat64 in _wasserstein:
_wasserstein.EMDBaseFloat64_swigregister(EMDBaseFloat64)
cvar = _wasserstein.cvar
PI = cvar.PI
TWOPI = cvar.TWOPI
COMPILED_WITH_OPENMP = cvar.COMPILED_WITH_OPENMP

class PairwiseEMDBaseFloat64(object):
    r"""Proxy of C++ wasserstein::PairwiseEMDBase< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _wasserstein.delete_PairwiseEMDBaseFloat64

    def R(self):
        r"""R(PairwiseEMDBaseFloat64 self) -> double"""
        return _wasserstein.PairwiseEMDBaseFloat64_R(self)

    def set_R(self, R):
        r"""set_R(PairwiseEMDBaseFloat64 self, double R)"""
        return _wasserstein.PairwiseEMDBaseFloat64_set_R(self, R)

    def beta(self):
        r"""beta(PairwiseEMDBaseFloat64 self) -> double"""
        return _wasserstein.PairwiseEMDBaseFloat64_beta(self)

    def set_beta(self, beta):
        r"""set_beta(PairwiseEMDBaseFloat64 self, double beta)"""
        return _wasserstein.PairwiseEMDBaseFloat64_set_beta(self, beta)

    def norm(self):
        r"""norm(PairwiseEMDBaseFloat64 self) -> bool"""
        return _wasserstein.PairwiseEMDBaseFloat64_norm(self)

    def set_norm(self, norm):
        r"""set_norm(PairwiseEMDBaseFloat64 self, bool norm)"""
        return _wasserstein.PairwiseEMDBaseFloat64_set_norm(self, norm)

    def set_network_simplex_params(self, n_iter_max=100000, epsilon_large_factor=1000, epsilon_small_factor=1):
        r"""set_network_simplex_params(PairwiseEMDBaseFloat64 self, std::size_t n_iter_max=100000, double epsilon_large_factor=1000, double epsilon_small_factor=1)"""
        return _wasserstein.PairwiseEMDBaseFloat64_set_network_simplex_params(self, n_iter_max, epsilon_large_factor, epsilon_small_factor)

    def set_external_emd_handler(self, handler):
        if not handler.thisown:
            raise RuntimeError('ExternalEMDHandler must own itself; perhaps it is already in use elsewhere')
        handler.thisown = 0
        _wasserstein.PairwiseEMDBaseFloat64_set_external_emd_handler(self, handler)
        self._external_emd_handler = handler



    def have_external_emd_handler(self):
        r"""have_external_emd_handler(PairwiseEMDBaseFloat64 self) -> bool"""
        return _wasserstein.PairwiseEMDBaseFloat64_have_external_emd_handler(self)

    def num_threads(self):
        r"""num_threads(PairwiseEMDBaseFloat64 self) -> int"""
        return _wasserstein.PairwiseEMDBaseFloat64_num_threads(self)

    def set_omp_dynamic_chunksize(self, chunksize):
        r"""set_omp_dynamic_chunksize(PairwiseEMDBaseFloat64 self, int chunksize)"""
        return _wasserstein.PairwiseEMDBaseFloat64_set_omp_dynamic_chunksize(self, chunksize)

    def omp_dynamic_chunksize(self):
        r"""omp_dynamic_chunksize(PairwiseEMDBaseFloat64 self) -> int"""
        return _wasserstein.PairwiseEMDBaseFloat64_omp_dynamic_chunksize(self)

    def set_request_mode(self, mode):
        r"""set_request_mode(PairwiseEMDBaseFloat64 self, bool mode)"""
        return _wasserstein.PairwiseEMDBaseFloat64_set_request_mode(self, mode)

    def request_mode(self):
        r"""request_mode(PairwiseEMDBaseFloat64 self) -> bool"""
        return _wasserstein.PairwiseEMDBaseFloat64_request_mode(self)

    def duration(self):
        r"""duration(PairwiseEMDBaseFloat64 self) -> double"""
        return _wasserstein.PairwiseEMDBaseFloat64_duration(self)

    def nevA(self):
        r"""nevA(PairwiseEMDBaseFloat64 self) -> wasserstein::index_type"""
        return _wasserstein.PairwiseEMDBaseFloat64_nevA(self)

    def nevB(self):
        r"""nevB(PairwiseEMDBaseFloat64 self) -> wasserstein::index_type"""
        return _wasserstein.PairwiseEMDBaseFloat64_nevB(self)

    def num_emds(self):
        r"""num_emds(PairwiseEMDBaseFloat64 self) -> wasserstein::index_type"""
        return _wasserstein.PairwiseEMDBaseFloat64_num_emds(self)

    def storage(self):
        r"""storage(PairwiseEMDBaseFloat64 self) -> wasserstein::EMDPairsStorage"""
        return _wasserstein.PairwiseEMDBaseFloat64_storage(self)

    def errored(self):
        r"""errored(PairwiseEMDBaseFloat64 self) -> bool"""
        return _wasserstein.PairwiseEMDBaseFloat64_errored(self)

    def error_messages(self):
        r"""error_messages(PairwiseEMDBaseFloat64 self) -> vectorString"""
        return _wasserstein.PairwiseEMDBaseFloat64_error_messages(self)

    def emds_vec(self, raw=False):
        r"""emds_vec(PairwiseEMDBaseFloat64 self, bool raw=False) -> vectorDouble"""
        return _wasserstein.PairwiseEMDBaseFloat64_emds_vec(self, raw)

    def emd(self, i, j, thread=0):
        r"""emd(PairwiseEMDBaseFloat64 self, wasserstein::index_type i, wasserstein::index_type j, int thread=0) -> double"""
        return _wasserstein.PairwiseEMDBaseFloat64_emd(self, i, j, thread)


          # ensure proper destruction of objects held by this instance
    def __del__(self):
        if hasattr(self, '_external_emd_handler'):
            self._external_emd_handler.thisown = 1
            del self._external_emd_handler

    def __call__(self, eventsA, eventsB=None, gdim=None, mask=False,
                       event_weightsA=None, event_weightsB=None):

        dtype = np.float64 if 'Float64' in self.__class__.__name__ else np.float32
        self._float_dtype = dtype

        if eventsB is None:
            self.init(len(eventsA))
            eventsB = event_weightsB = []
        else:
            self.init(len(eventsA), len(eventsB))

        if event_weightsA is None:
            event_weightsA = np.ones(len(eventsA))
        elif len(event_weightsA) != len(eventsA):
            raise ValueError('length of `event_weightsA` does not match length of `eventsA`')

        if event_weightsB is None:
            event_weightsB = np.ones(len(eventsB))
        elif len(event_weightsB) != len(eventsB):
            raise ValueError('length of `event_weightsB` does not match length of `eventsB`')

        self.event_arrs = []
        _store_events(self, itertools.chain(eventsA, eventsB),
                            itertools.chain(event_weightsA, event_weightsB),
                            gdim, mask, dtype)

        if not self.request_mode():
            self.compute()


    def emds(self):
        r"""emds(PairwiseEMDBaseFloat64 self)"""
        return _wasserstein.PairwiseEMDBaseFloat64_emds(self)

    def raw_emds(self):
        r"""raw_emds(PairwiseEMDBaseFloat64 self)"""
        return _wasserstein.PairwiseEMDBaseFloat64_raw_emds(self)

# Register PairwiseEMDBaseFloat64 in _wasserstein:
_wasserstein.PairwiseEMDBaseFloat64_swigregister(PairwiseEMDBaseFloat64)
class ExternalEMDHandlerFloat64(object):
    r"""Proxy of C++ wasserstein::ExternalEMDHandler< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _wasserstein.delete_ExternalEMDHandlerFloat64

    def description(self):
        r"""description(ExternalEMDHandlerFloat64 self) -> std::string"""
        return _wasserstein.ExternalEMDHandlerFloat64_description(self)

    def num_calls(self):
        r"""num_calls(ExternalEMDHandlerFloat64 self) -> std::size_t"""
        return _wasserstein.ExternalEMDHandlerFloat64_num_calls(self)

    def __call__(self, emd, weight=1):
        r"""__call__(ExternalEMDHandlerFloat64 self, double emd, double weight=1)"""
        return _wasserstein.ExternalEMDHandlerFloat64___call__(self, emd, weight)

    def evaluate1d(self, *args):
        r"""
        evaluate1d(ExternalEMDHandlerFloat64 self, double * emds)
        evaluate1d(ExternalEMDHandlerFloat64 self, double * emds, double * event_weights)
        """
        return _wasserstein.ExternalEMDHandlerFloat64_evaluate1d(self, *args)

    def evaluate2d(self, *args):
        r"""
        evaluate2d(ExternalEMDHandlerFloat64 self, double * emds)
        evaluate2d(ExternalEMDHandlerFloat64 self, double * emds, double * event_weights)
        evaluate2d(ExternalEMDHandlerFloat64 self, double * emds, double * event_weightsA, double * event_weightsB)
        """
        return _wasserstein.ExternalEMDHandlerFloat64_evaluate2d(self, *args)

    def evaluate1d_symmetric(self, emds, event_weights, upper_triangular=True):
        r"""evaluate1d_symmetric(ExternalEMDHandlerFloat64 self, double * emds, double * event_weights, bool upper_triangular=True)"""
        return _wasserstein.ExternalEMDHandlerFloat64_evaluate1d_symmetric(self, emds, event_weights, upper_triangular)

# Register ExternalEMDHandlerFloat64 in _wasserstein:
_wasserstein.ExternalEMDHandlerFloat64_swigregister(ExternalEMDHandlerFloat64)
class Histogram1DHandlerLogFloat64(ExternalEMDHandlerFloat64):
    r"""Proxy of C++ wasserstein::Histogram1DHandler< boost::histogram::axis::transform::log,double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, nbins, axis_min, axis_max):
        r"""__init__(Histogram1DHandlerLogFloat64 self, unsigned int nbins, double axis_min, double axis_max) -> Histogram1DHandlerLogFloat64"""
        _wasserstein.Histogram1DHandlerLogFloat64_swiginit(self, _wasserstein.new_Histogram1DHandlerLogFloat64(nbins, axis_min, axis_max))
    __swig_destroy__ = _wasserstein.delete_Histogram1DHandlerLogFloat64

    def nbins(self):
        r"""nbins(Histogram1DHandlerLogFloat64 self) -> unsigned int"""
        return _wasserstein.Histogram1DHandlerLogFloat64_nbins(self)

    def axis_min(self):
        r"""axis_min(Histogram1DHandlerLogFloat64 self) -> double"""
        return _wasserstein.Histogram1DHandlerLogFloat64_axis_min(self)

    def axis_max(self):
        r"""axis_max(Histogram1DHandlerLogFloat64 self) -> double"""
        return _wasserstein.Histogram1DHandlerLogFloat64_axis_max(self)

    def description(self):
        r"""description(Histogram1DHandlerLogFloat64 self) -> std::string"""
        return _wasserstein.Histogram1DHandlerLogFloat64_description(self)

    def hist_vals_vars_vec(self, overflows=True):
        r"""hist_vals_vars_vec(Histogram1DHandlerLogFloat64 self, bool overflows=True) -> pairVectorDouble"""
        return _wasserstein.Histogram1DHandlerLogFloat64_hist_vals_vars_vec(self, overflows)

    def bin_centers_vec(self):
        r"""bin_centers_vec(Histogram1DHandlerLogFloat64 self) -> vectorDouble"""
        return _wasserstein.Histogram1DHandlerLogFloat64_bin_centers_vec(self)

    def bin_edges_vec(self):
        r"""bin_edges_vec(Histogram1DHandlerLogFloat64 self) -> vectorDouble"""
        return _wasserstein.Histogram1DHandlerLogFloat64_bin_edges_vec(self)

    def __iadd__(self, other):
        r"""__iadd__(Histogram1DHandlerLogFloat64 self, Histogram1DHandlerLogFloat64 other) -> Histogram1DHandlerLogFloat64"""
        return _wasserstein.Histogram1DHandlerLogFloat64___iadd__(self, other)

    def __repr__(self):
        r"""__repr__(Histogram1DHandlerLogFloat64 self) -> std::string"""
        return _wasserstein.Histogram1DHandlerLogFloat64___repr__(self)

    def bin_centers(self):
        r"""bin_centers(Histogram1DHandlerLogFloat64 self)"""
        return _wasserstein.Histogram1DHandlerLogFloat64_bin_centers(self)

    def bin_edges(self):
        r"""bin_edges(Histogram1DHandlerLogFloat64 self)"""
        return _wasserstein.Histogram1DHandlerLogFloat64_bin_edges(self)

    def hist_vals_vars(self, overflows=True):
        r"""hist_vals_vars(Histogram1DHandlerLogFloat64 self, bool overflows=True)"""
        return _wasserstein.Histogram1DHandlerLogFloat64_hist_vals_vars(self, overflows)

    def hist_vals_errs(self, overflows=True):
        vals, vars = self.hist_vals_vars(overflows)
        return vals, np.sqrt(vars)


# Register Histogram1DHandlerLogFloat64 in _wasserstein:
_wasserstein.Histogram1DHandlerLogFloat64_swigregister(Histogram1DHandlerLogFloat64)
class Histogram1DHandlerFloat64(ExternalEMDHandlerFloat64):
    r"""Proxy of C++ wasserstein::Histogram1DHandler< boost::histogram::axis::transform::id,double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, nbins, axis_min, axis_max):
        r"""__init__(Histogram1DHandlerFloat64 self, unsigned int nbins, double axis_min, double axis_max) -> Histogram1DHandlerFloat64"""
        _wasserstein.Histogram1DHandlerFloat64_swiginit(self, _wasserstein.new_Histogram1DHandlerFloat64(nbins, axis_min, axis_max))
    __swig_destroy__ = _wasserstein.delete_Histogram1DHandlerFloat64

    def nbins(self):
        r"""nbins(Histogram1DHandlerFloat64 self) -> unsigned int"""
        return _wasserstein.Histogram1DHandlerFloat64_nbins(self)

    def axis_min(self):
        r"""axis_min(Histogram1DHandlerFloat64 self) -> double"""
        return _wasserstein.Histogram1DHandlerFloat64_axis_min(self)

    def axis_max(self):
        r"""axis_max(Histogram1DHandlerFloat64 self) -> double"""
        return _wasserstein.Histogram1DHandlerFloat64_axis_max(self)

    def description(self):
        r"""description(Histogram1DHandlerFloat64 self) -> std::string"""
        return _wasserstein.Histogram1DHandlerFloat64_description(self)

    def hist_vals_vars_vec(self, overflows=True):
        r"""hist_vals_vars_vec(Histogram1DHandlerFloat64 self, bool overflows=True) -> pairVectorDouble"""
        return _wasserstein.Histogram1DHandlerFloat64_hist_vals_vars_vec(self, overflows)

    def bin_centers_vec(self):
        r"""bin_centers_vec(Histogram1DHandlerFloat64 self) -> vectorDouble"""
        return _wasserstein.Histogram1DHandlerFloat64_bin_centers_vec(self)

    def bin_edges_vec(self):
        r"""bin_edges_vec(Histogram1DHandlerFloat64 self) -> vectorDouble"""
        return _wasserstein.Histogram1DHandlerFloat64_bin_edges_vec(self)

    def __iadd__(self, other):
        r"""__iadd__(Histogram1DHandlerFloat64 self, Histogram1DHandlerFloat64 other) -> Histogram1DHandlerFloat64"""
        return _wasserstein.Histogram1DHandlerFloat64___iadd__(self, other)

    def __repr__(self):
        r"""__repr__(Histogram1DHandlerFloat64 self) -> std::string"""
        return _wasserstein.Histogram1DHandlerFloat64___repr__(self)

    def bin_centers(self):
        r"""bin_centers(Histogram1DHandlerFloat64 self)"""
        return _wasserstein.Histogram1DHandlerFloat64_bin_centers(self)

    def bin_edges(self):
        r"""bin_edges(Histogram1DHandlerFloat64 self)"""
        return _wasserstein.Histogram1DHandlerFloat64_bin_edges(self)

    def hist_vals_vars(self, overflows=True):
        r"""hist_vals_vars(Histogram1DHandlerFloat64 self, bool overflows=True)"""
        return _wasserstein.Histogram1DHandlerFloat64_hist_vals_vars(self, overflows)

    def hist_vals_errs(self, overflows=True):
        vals, vars = self.hist_vals_vars(overflows)
        return vals, np.sqrt(vars)


# Register Histogram1DHandlerFloat64 in _wasserstein:
_wasserstein.Histogram1DHandlerFloat64_swigregister(Histogram1DHandlerFloat64)
class EMDBaseFloat32(object):
    r"""Proxy of C++ wasserstein::EMDBase< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _wasserstein.delete_EMDBaseFloat32

    def R(self):
        r"""R(EMDBaseFloat32 self) -> float"""
        return _wasserstein.EMDBaseFloat32_R(self)

    def beta(self):
        r"""beta(EMDBaseFloat32 self) -> float"""
        return _wasserstein.EMDBaseFloat32_beta(self)

    def set_R(self, R):
        r"""set_R(EMDBaseFloat32 self, float R)"""
        return _wasserstein.EMDBaseFloat32_set_R(self, R)

    def set_beta(self, beta):
        r"""set_beta(EMDBaseFloat32 self, float beta)"""
        return _wasserstein.EMDBaseFloat32_set_beta(self, beta)

    def set_network_simplex_params(self, n_iter_max=100000, epsilon_large_factor=1000, epsilon_small_factor=1):
        r"""set_network_simplex_params(EMDBaseFloat32 self, std::size_t n_iter_max=100000, float epsilon_large_factor=1000, float epsilon_small_factor=1)"""
        return _wasserstein.EMDBaseFloat32_set_network_simplex_params(self, n_iter_max, epsilon_large_factor, epsilon_small_factor)

    def norm(self):
        r"""norm(EMDBaseFloat32 self) -> bool"""
        return _wasserstein.EMDBaseFloat32_norm(self)

    def set_norm(self, norm):
        r"""set_norm(EMDBaseFloat32 self, bool norm)"""
        return _wasserstein.EMDBaseFloat32_set_norm(self, norm)

    def do_timing(self):
        r"""do_timing(EMDBaseFloat32 self) -> bool"""
        return _wasserstein.EMDBaseFloat32_do_timing(self)

    def set_do_timing(self, timing):
        r"""set_do_timing(EMDBaseFloat32 self, bool timing)"""
        return _wasserstein.EMDBaseFloat32_set_do_timing(self, timing)

    def external_dists(self):
        r"""external_dists(EMDBaseFloat32 self) -> bool"""
        return _wasserstein.EMDBaseFloat32_external_dists(self)

    def set_external_dists(self, exdists):
        r"""set_external_dists(EMDBaseFloat32 self, bool exdists)"""
        return _wasserstein.EMDBaseFloat32_set_external_dists(self, exdists)

    def n0(self):
        r"""n0(EMDBaseFloat32 self) -> wasserstein::index_type"""
        return _wasserstein.EMDBaseFloat32_n0(self)

    def n1(self):
        r"""n1(EMDBaseFloat32 self) -> wasserstein::index_type"""
        return _wasserstein.EMDBaseFloat32_n1(self)

    def extra(self):
        r"""extra(EMDBaseFloat32 self) -> wasserstein::ExtraParticle"""
        return _wasserstein.EMDBaseFloat32_extra(self)

    def emd(self):
        r"""emd(EMDBaseFloat32 self) -> float"""
        return _wasserstein.EMDBaseFloat32_emd(self)

    def status(self):
        r"""status(EMDBaseFloat32 self) -> wasserstein::EMDStatus"""
        return _wasserstein.EMDBaseFloat32_status(self)

    def weightdiff(self):
        r"""weightdiff(EMDBaseFloat32 self) -> float"""
        return _wasserstein.EMDBaseFloat32_weightdiff(self)

    def scale(self):
        r"""scale(EMDBaseFloat32 self) -> float"""
        return _wasserstein.EMDBaseFloat32_scale(self)

    def n_iter(self):
        r"""n_iter(EMDBaseFloat32 self) -> std::size_t"""
        return _wasserstein.EMDBaseFloat32_n_iter(self)

    def dists_vec(self):
        r"""dists_vec(EMDBaseFloat32 self) -> vectorFloat"""
        return _wasserstein.EMDBaseFloat32_dists_vec(self)

    def flows_vec(self):
        r"""flows_vec(EMDBaseFloat32 self) -> vectorFloat"""
        return _wasserstein.EMDBaseFloat32_flows_vec(self)

    def flow(self, *args):
        r"""
        flow(EMDBaseFloat32 self, wasserstein::index_type i, wasserstein::index_type j) -> float
        flow(EMDBaseFloat32 self, std::size_t ind) -> float
        """
        return _wasserstein.EMDBaseFloat32_flow(self, *args)

    def node_potentials(self):
        r"""node_potentials(EMDBaseFloat32 self) -> pairVectorFloat"""
        return _wasserstein.EMDBaseFloat32_node_potentials(self)

    def duration(self):
        r"""duration(EMDBaseFloat32 self) -> double"""
        return _wasserstein.EMDBaseFloat32_duration(self)

    def clear(self):
        r"""clear(EMDBaseFloat32 self)"""
        return _wasserstein.EMDBaseFloat32_clear(self)

    def flows(self):
        r"""flows(EMDBaseFloat32 self)"""
        return _wasserstein.EMDBaseFloat32_flows(self)

    def dists(self):
        r"""dists(EMDBaseFloat32 self)"""
        return _wasserstein.EMDBaseFloat32_dists(self)

    def npy_node_potentials(self):
        r"""npy_node_potentials(EMDBaseFloat32 self)"""
        return _wasserstein.EMDBaseFloat32_npy_node_potentials(self)

# Register EMDBaseFloat32 in _wasserstein:
_wasserstein.EMDBaseFloat32_swigregister(EMDBaseFloat32)
class PairwiseEMDBaseFloat32(object):
    r"""Proxy of C++ wasserstein::PairwiseEMDBase< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _wasserstein.delete_PairwiseEMDBaseFloat32

    def R(self):
        r"""R(PairwiseEMDBaseFloat32 self) -> float"""
        return _wasserstein.PairwiseEMDBaseFloat32_R(self)

    def set_R(self, R):
        r"""set_R(PairwiseEMDBaseFloat32 self, float R)"""
        return _wasserstein.PairwiseEMDBaseFloat32_set_R(self, R)

    def beta(self):
        r"""beta(PairwiseEMDBaseFloat32 self) -> float"""
        return _wasserstein.PairwiseEMDBaseFloat32_beta(self)

    def set_beta(self, beta):
        r"""set_beta(PairwiseEMDBaseFloat32 self, float beta)"""
        return _wasserstein.PairwiseEMDBaseFloat32_set_beta(self, beta)

    def norm(self):
        r"""norm(PairwiseEMDBaseFloat32 self) -> bool"""
        return _wasserstein.PairwiseEMDBaseFloat32_norm(self)

    def set_norm(self, norm):
        r"""set_norm(PairwiseEMDBaseFloat32 self, bool norm)"""
        return _wasserstein.PairwiseEMDBaseFloat32_set_norm(self, norm)

    def set_network_simplex_params(self, n_iter_max=100000, epsilon_large_factor=1000, epsilon_small_factor=1):
        r"""set_network_simplex_params(PairwiseEMDBaseFloat32 self, std::size_t n_iter_max=100000, float epsilon_large_factor=1000, float epsilon_small_factor=1)"""
        return _wasserstein.PairwiseEMDBaseFloat32_set_network_simplex_params(self, n_iter_max, epsilon_large_factor, epsilon_small_factor)

    def set_external_emd_handler(self, handler):
        if not handler.thisown:
            raise RuntimeError('ExternalEMDHandler must own itself; perhaps it is already in use elsewhere')
        handler.thisown = 0
        _wasserstein.PairwiseEMDBaseFloat32_set_external_emd_handler(self, handler)
        self._external_emd_handler = handler



    def have_external_emd_handler(self):
        r"""have_external_emd_handler(PairwiseEMDBaseFloat32 self) -> bool"""
        return _wasserstein.PairwiseEMDBaseFloat32_have_external_emd_handler(self)

    def num_threads(self):
        r"""num_threads(PairwiseEMDBaseFloat32 self) -> int"""
        return _wasserstein.PairwiseEMDBaseFloat32_num_threads(self)

    def set_omp_dynamic_chunksize(self, chunksize):
        r"""set_omp_dynamic_chunksize(PairwiseEMDBaseFloat32 self, int chunksize)"""
        return _wasserstein.PairwiseEMDBaseFloat32_set_omp_dynamic_chunksize(self, chunksize)

    def omp_dynamic_chunksize(self):
        r"""omp_dynamic_chunksize(PairwiseEMDBaseFloat32 self) -> int"""
        return _wasserstein.PairwiseEMDBaseFloat32_omp_dynamic_chunksize(self)

    def set_request_mode(self, mode):
        r"""set_request_mode(PairwiseEMDBaseFloat32 self, bool mode)"""
        return _wasserstein.PairwiseEMDBaseFloat32_set_request_mode(self, mode)

    def request_mode(self):
        r"""request_mode(PairwiseEMDBaseFloat32 self) -> bool"""
        return _wasserstein.PairwiseEMDBaseFloat32_request_mode(self)

    def duration(self):
        r"""duration(PairwiseEMDBaseFloat32 self) -> double"""
        return _wasserstein.PairwiseEMDBaseFloat32_duration(self)

    def nevA(self):
        r"""nevA(PairwiseEMDBaseFloat32 self) -> wasserstein::index_type"""
        return _wasserstein.PairwiseEMDBaseFloat32_nevA(self)

    def nevB(self):
        r"""nevB(PairwiseEMDBaseFloat32 self) -> wasserstein::index_type"""
        return _wasserstein.PairwiseEMDBaseFloat32_nevB(self)

    def num_emds(self):
        r"""num_emds(PairwiseEMDBaseFloat32 self) -> wasserstein::index_type"""
        return _wasserstein.PairwiseEMDBaseFloat32_num_emds(self)

    def storage(self):
        r"""storage(PairwiseEMDBaseFloat32 self) -> wasserstein::EMDPairsStorage"""
        return _wasserstein.PairwiseEMDBaseFloat32_storage(self)

    def errored(self):
        r"""errored(PairwiseEMDBaseFloat32 self) -> bool"""
        return _wasserstein.PairwiseEMDBaseFloat32_errored(self)

    def error_messages(self):
        r"""error_messages(PairwiseEMDBaseFloat32 self) -> vectorString"""
        return _wasserstein.PairwiseEMDBaseFloat32_error_messages(self)

    def emds_vec(self, raw=False):
        r"""emds_vec(PairwiseEMDBaseFloat32 self, bool raw=False) -> vectorFloat"""
        return _wasserstein.PairwiseEMDBaseFloat32_emds_vec(self, raw)

    def emd(self, i, j, thread=0):
        r"""emd(PairwiseEMDBaseFloat32 self, wasserstein::index_type i, wasserstein::index_type j, int thread=0) -> float"""
        return _wasserstein.PairwiseEMDBaseFloat32_emd(self, i, j, thread)


          # ensure proper destruction of objects held by this instance
    def __del__(self):
        if hasattr(self, '_external_emd_handler'):
            self._external_emd_handler.thisown = 1
            del self._external_emd_handler

    def __call__(self, eventsA, eventsB=None, gdim=None, mask=False,
                       event_weightsA=None, event_weightsB=None):

        dtype = np.float64 if 'Float64' in self.__class__.__name__ else np.float32
        self._float_dtype = dtype

        if eventsB is None:
            self.init(len(eventsA))
            eventsB = event_weightsB = []
        else:
            self.init(len(eventsA), len(eventsB))

        if event_weightsA is None:
            event_weightsA = np.ones(len(eventsA))
        elif len(event_weightsA) != len(eventsA):
            raise ValueError('length of `event_weightsA` does not match length of `eventsA`')

        if event_weightsB is None:
            event_weightsB = np.ones(len(eventsB))
        elif len(event_weightsB) != len(eventsB):
            raise ValueError('length of `event_weightsB` does not match length of `eventsB`')

        self.event_arrs = []
        _store_events(self, itertools.chain(eventsA, eventsB),
                            itertools.chain(event_weightsA, event_weightsB),
                            gdim, mask, dtype)

        if not self.request_mode():
            self.compute()


    def emds(self):
        r"""emds(PairwiseEMDBaseFloat32 self)"""
        return _wasserstein.PairwiseEMDBaseFloat32_emds(self)

    def raw_emds(self):
        r"""raw_emds(PairwiseEMDBaseFloat32 self)"""
        return _wasserstein.PairwiseEMDBaseFloat32_raw_emds(self)

# Register PairwiseEMDBaseFloat32 in _wasserstein:
_wasserstein.PairwiseEMDBaseFloat32_swigregister(PairwiseEMDBaseFloat32)
class ExternalEMDHandlerFloat32(object):
    r"""Proxy of C++ wasserstein::ExternalEMDHandler< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _wasserstein.delete_ExternalEMDHandlerFloat32

    def description(self):
        r"""description(ExternalEMDHandlerFloat32 self) -> std::string"""
        return _wasserstein.ExternalEMDHandlerFloat32_description(self)

    def num_calls(self):
        r"""num_calls(ExternalEMDHandlerFloat32 self) -> std::size_t"""
        return _wasserstein.ExternalEMDHandlerFloat32_num_calls(self)

    def __call__(self, emd, weight=1):
        r"""__call__(ExternalEMDHandlerFloat32 self, float emd, float weight=1)"""
        return _wasserstein.ExternalEMDHandlerFloat32___call__(self, emd, weight)

    def evaluate1d(self, *args):
        r"""
        evaluate1d(ExternalEMDHandlerFloat32 self, float * emds)
        evaluate1d(ExternalEMDHandlerFloat32 self, float * emds, float * event_weights)
        """
        return _wasserstein.ExternalEMDHandlerFloat32_evaluate1d(self, *args)

    def evaluate2d(self, *args):
        r"""
        evaluate2d(ExternalEMDHandlerFloat32 self, float * emds)
        evaluate2d(ExternalEMDHandlerFloat32 self, float * emds, float * event_weights)
        evaluate2d(ExternalEMDHandlerFloat32 self, float * emds, float * event_weightsA, float * event_weightsB)
        """
        return _wasserstein.ExternalEMDHandlerFloat32_evaluate2d(self, *args)

    def evaluate1d_symmetric(self, emds, event_weights, upper_triangular=True):
        r"""evaluate1d_symmetric(ExternalEMDHandlerFloat32 self, float * emds, float * event_weights, bool upper_triangular=True)"""
        return _wasserstein.ExternalEMDHandlerFloat32_evaluate1d_symmetric(self, emds, event_weights, upper_triangular)

# Register ExternalEMDHandlerFloat32 in _wasserstein:
_wasserstein.ExternalEMDHandlerFloat32_swigregister(ExternalEMDHandlerFloat32)
class Histogram1DHandlerLogFloat32(ExternalEMDHandlerFloat32):
    r"""Proxy of C++ wasserstein::Histogram1DHandler< boost::histogram::axis::transform::log,float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, nbins, axis_min, axis_max):
        r"""__init__(Histogram1DHandlerLogFloat32 self, unsigned int nbins, float axis_min, float axis_max) -> Histogram1DHandlerLogFloat32"""
        _wasserstein.Histogram1DHandlerLogFloat32_swiginit(self, _wasserstein.new_Histogram1DHandlerLogFloat32(nbins, axis_min, axis_max))
    __swig_destroy__ = _wasserstein.delete_Histogram1DHandlerLogFloat32

    def nbins(self):
        r"""nbins(Histogram1DHandlerLogFloat32 self) -> unsigned int"""
        return _wasserstein.Histogram1DHandlerLogFloat32_nbins(self)

    def axis_min(self):
        r"""axis_min(Histogram1DHandlerLogFloat32 self) -> float"""
        return _wasserstein.Histogram1DHandlerLogFloat32_axis_min(self)

    def axis_max(self):
        r"""axis_max(Histogram1DHandlerLogFloat32 self) -> float"""
        return _wasserstein.Histogram1DHandlerLogFloat32_axis_max(self)

    def description(self):
        r"""description(Histogram1DHandlerLogFloat32 self) -> std::string"""
        return _wasserstein.Histogram1DHandlerLogFloat32_description(self)

    def hist_vals_vars_vec(self, overflows=True):
        r"""hist_vals_vars_vec(Histogram1DHandlerLogFloat32 self, bool overflows=True) -> pairVectorFloat"""
        return _wasserstein.Histogram1DHandlerLogFloat32_hist_vals_vars_vec(self, overflows)

    def bin_centers_vec(self):
        r"""bin_centers_vec(Histogram1DHandlerLogFloat32 self) -> vectorFloat"""
        return _wasserstein.Histogram1DHandlerLogFloat32_bin_centers_vec(self)

    def bin_edges_vec(self):
        r"""bin_edges_vec(Histogram1DHandlerLogFloat32 self) -> vectorFloat"""
        return _wasserstein.Histogram1DHandlerLogFloat32_bin_edges_vec(self)

    def __iadd__(self, other):
        r"""__iadd__(Histogram1DHandlerLogFloat32 self, Histogram1DHandlerLogFloat32 other) -> Histogram1DHandlerLogFloat32"""
        return _wasserstein.Histogram1DHandlerLogFloat32___iadd__(self, other)

    def __repr__(self):
        r"""__repr__(Histogram1DHandlerLogFloat32 self) -> std::string"""
        return _wasserstein.Histogram1DHandlerLogFloat32___repr__(self)

    def bin_centers(self):
        r"""bin_centers(Histogram1DHandlerLogFloat32 self)"""
        return _wasserstein.Histogram1DHandlerLogFloat32_bin_centers(self)

    def bin_edges(self):
        r"""bin_edges(Histogram1DHandlerLogFloat32 self)"""
        return _wasserstein.Histogram1DHandlerLogFloat32_bin_edges(self)

    def hist_vals_vars(self, overflows=True):
        r"""hist_vals_vars(Histogram1DHandlerLogFloat32 self, bool overflows=True)"""
        return _wasserstein.Histogram1DHandlerLogFloat32_hist_vals_vars(self, overflows)

    def hist_vals_errs(self, overflows=True):
        vals, vars = self.hist_vals_vars(overflows)
        return vals, np.sqrt(vars)


# Register Histogram1DHandlerLogFloat32 in _wasserstein:
_wasserstein.Histogram1DHandlerLogFloat32_swigregister(Histogram1DHandlerLogFloat32)
class Histogram1DHandlerFloat32(ExternalEMDHandlerFloat32):
    r"""Proxy of C++ wasserstein::Histogram1DHandler< boost::histogram::axis::transform::id,float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, nbins, axis_min, axis_max):
        r"""__init__(Histogram1DHandlerFloat32 self, unsigned int nbins, float axis_min, float axis_max) -> Histogram1DHandlerFloat32"""
        _wasserstein.Histogram1DHandlerFloat32_swiginit(self, _wasserstein.new_Histogram1DHandlerFloat32(nbins, axis_min, axis_max))
    __swig_destroy__ = _wasserstein.delete_Histogram1DHandlerFloat32

    def nbins(self):
        r"""nbins(Histogram1DHandlerFloat32 self) -> unsigned int"""
        return _wasserstein.Histogram1DHandlerFloat32_nbins(self)

    def axis_min(self):
        r"""axis_min(Histogram1DHandlerFloat32 self) -> float"""
        return _wasserstein.Histogram1DHandlerFloat32_axis_min(self)

    def axis_max(self):
        r"""axis_max(Histogram1DHandlerFloat32 self) -> float"""
        return _wasserstein.Histogram1DHandlerFloat32_axis_max(self)

    def description(self):
        r"""description(Histogram1DHandlerFloat32 self) -> std::string"""
        return _wasserstein.Histogram1DHandlerFloat32_description(self)

    def hist_vals_vars_vec(self, overflows=True):
        r"""hist_vals_vars_vec(Histogram1DHandlerFloat32 self, bool overflows=True) -> pairVectorFloat"""
        return _wasserstein.Histogram1DHandlerFloat32_hist_vals_vars_vec(self, overflows)

    def bin_centers_vec(self):
        r"""bin_centers_vec(Histogram1DHandlerFloat32 self) -> vectorFloat"""
        return _wasserstein.Histogram1DHandlerFloat32_bin_centers_vec(self)

    def bin_edges_vec(self):
        r"""bin_edges_vec(Histogram1DHandlerFloat32 self) -> vectorFloat"""
        return _wasserstein.Histogram1DHandlerFloat32_bin_edges_vec(self)

    def __iadd__(self, other):
        r"""__iadd__(Histogram1DHandlerFloat32 self, Histogram1DHandlerFloat32 other) -> Histogram1DHandlerFloat32"""
        return _wasserstein.Histogram1DHandlerFloat32___iadd__(self, other)

    def __repr__(self):
        r"""__repr__(Histogram1DHandlerFloat32 self) -> std::string"""
        return _wasserstein.Histogram1DHandlerFloat32___repr__(self)

    def bin_centers(self):
        r"""bin_centers(Histogram1DHandlerFloat32 self)"""
        return _wasserstein.Histogram1DHandlerFloat32_bin_centers(self)

    def bin_edges(self):
        r"""bin_edges(Histogram1DHandlerFloat32 self)"""
        return _wasserstein.Histogram1DHandlerFloat32_bin_edges(self)

    def hist_vals_vars(self, overflows=True):
        r"""hist_vals_vars(Histogram1DHandlerFloat32 self, bool overflows=True)"""
        return _wasserstein.Histogram1DHandlerFloat32_hist_vals_vars(self, overflows)

    def hist_vals_errs(self, overflows=True):
        vals, vars = self.hist_vals_vars(overflows)
        return vals, np.sqrt(vars)


# Register Histogram1DHandlerFloat32 in _wasserstein:
_wasserstein.Histogram1DHandlerFloat32_swigregister(Histogram1DHandlerFloat32)
class CorrelationDimensionFloat32(Histogram1DHandlerLogFloat32):
    r"""Proxy of C++ wasserstein::CorrelationDimension< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, nbins, axis_min, axis_max):
        r"""__init__(CorrelationDimensionFloat32 self, unsigned int nbins, float axis_min, float axis_max) -> CorrelationDimensionFloat32"""
        _wasserstein.CorrelationDimensionFloat32_swiginit(self, _wasserstein.new_CorrelationDimensionFloat32(nbins, axis_min, axis_max))

    def corrdims_vec(self, *args):
        r"""corrdims_vec(CorrelationDimensionFloat32 self, float eps=std::numeric_limits< float >::epsilon()) -> pairVectorFloat"""
        return _wasserstein.CorrelationDimensionFloat32_corrdims_vec(self, *args)

    def corrdim_bins_vec(self):
        r"""corrdim_bins_vec(CorrelationDimensionFloat32 self) -> vectorFloat"""
        return _wasserstein.CorrelationDimensionFloat32_corrdim_bins_vec(self)

    def cumulative_vals_vars_vec(self):
        r"""cumulative_vals_vars_vec(CorrelationDimensionFloat32 self) -> pairVectorFloat"""
        return _wasserstein.CorrelationDimensionFloat32_cumulative_vals_vars_vec(self)

    def __repr__(self):
        r"""__repr__(CorrelationDimensionFloat32 self) -> std::string"""
        return _wasserstein.CorrelationDimensionFloat32___repr__(self)

    def corrdim_bins(self):
        r"""corrdim_bins(CorrelationDimensionFloat32 self)"""
        return _wasserstein.CorrelationDimensionFloat32_corrdim_bins(self)

    def corrdims(self):
        r"""corrdims(CorrelationDimensionFloat32 self)"""
        return _wasserstein.CorrelationDimensionFloat32_corrdims(self)

    def cumulative_vals_vars(self):
        r"""cumulative_vals_vars(CorrelationDimensionFloat32 self)"""
        return _wasserstein.CorrelationDimensionFloat32_cumulative_vals_vars(self)
    __swig_destroy__ = _wasserstein.delete_CorrelationDimensionFloat32

# Register CorrelationDimensionFloat32 in _wasserstein:
_wasserstein.CorrelationDimensionFloat32_swigregister(CorrelationDimensionFloat32)
class CorrelationDimensionFloat64(Histogram1DHandlerLogFloat64):
    r"""Proxy of C++ wasserstein::CorrelationDimension< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, nbins, axis_min, axis_max):
        r"""__init__(CorrelationDimensionFloat64 self, unsigned int nbins, double axis_min, double axis_max) -> CorrelationDimensionFloat64"""
        _wasserstein.CorrelationDimensionFloat64_swiginit(self, _wasserstein.new_CorrelationDimensionFloat64(nbins, axis_min, axis_max))

    def corrdims_vec(self, *args):
        r"""corrdims_vec(CorrelationDimensionFloat64 self, double eps=std::numeric_limits< double >::epsilon()) -> pairVectorDouble"""
        return _wasserstein.CorrelationDimensionFloat64_corrdims_vec(self, *args)

    def corrdim_bins_vec(self):
        r"""corrdim_bins_vec(CorrelationDimensionFloat64 self) -> vectorDouble"""
        return _wasserstein.CorrelationDimensionFloat64_corrdim_bins_vec(self)

    def cumulative_vals_vars_vec(self):
        r"""cumulative_vals_vars_vec(CorrelationDimensionFloat64 self) -> pairVectorDouble"""
        return _wasserstein.CorrelationDimensionFloat64_cumulative_vals_vars_vec(self)

    def __repr__(self):
        r"""__repr__(CorrelationDimensionFloat64 self) -> std::string"""
        return _wasserstein.CorrelationDimensionFloat64___repr__(self)

    def corrdim_bins(self):
        r"""corrdim_bins(CorrelationDimensionFloat64 self)"""
        return _wasserstein.CorrelationDimensionFloat64_corrdim_bins(self)

    def corrdims(self):
        r"""corrdims(CorrelationDimensionFloat64 self)"""
        return _wasserstein.CorrelationDimensionFloat64_corrdims(self)

    def cumulative_vals_vars(self):
        r"""cumulative_vals_vars(CorrelationDimensionFloat64 self)"""
        return _wasserstein.CorrelationDimensionFloat64_cumulative_vals_vars(self)
    __swig_destroy__ = _wasserstein.delete_CorrelationDimensionFloat64

# Register CorrelationDimensionFloat64 in _wasserstein:
_wasserstein.CorrelationDimensionFloat64_swigregister(CorrelationDimensionFloat64)

def CorrelationDimension(*args, **kwargs):
    dtype = kwargs.pop('dtype', 'float64')
    if dtype == 'float64' or dtype == np.float64:
        return CorrelationDimensionFloat64(*args, **kwargs)
    elif dtype == 'float32' or dtype == np.float32:
        return CorrelationDimensionFloat32(*args, **kwargs)
    else:
      raise TypeError('`dtype` {} not supported'.format(dtype))



# function for storing events in a pairwise_emd object
def _store_events(pairwise_emd, events, event_weights, gdim, mask, dtype):

    if mask:
        R2 = pairwise_emd.R()**2

    for event, event_weight in zip(events, event_weights):

# ensure event is 2d
        event = np.asarray(event)
        if event.ndim != 2:
            raise ValueError('event must be a 2-dimensional array')
        if gdim is not None:
            if event.shape[1] <= gdim:
                raise ValueError('event should have at least gdim={} coordinates'.format(gdim))
            event = event[:,:1+gdim]

# consider mask
        if mask:
            event = event[np.sum(event[:,1:]**2, axis=1) <= R2]

# extract weights and coords
# usually, these would make copies anyway
# sometimes, e.g. in the case of a single particle, they may not
# weights are never modified due to internal copying
# coords may be modified (e.g. by centering), so we always make a copy of them
        weights = np.asarray(event[:,0], dtype=dtype, order='C')
        coords = np.array(event[:,1:], dtype=dtype, order='C', copy=True)

# ensure that the lifetime of these arrays lasts through the computation
        pairwise_emd.event_arrs.append((weights, coords))

# store individual event
        pairwise_emd._add_event(weights, coords, float(event_weight))

class EMDFloat64(EMDBaseFloat64):
    r"""Proxy of C++ wasserstein::EMD< double,wasserstein::DefaultArrayEvent,wasserstein::EuclideanArrayDistance > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, R=1, beta=1, norm=False, do_timing=False, external_dists=False, n_iter_max=100000, epsilon_large_factor=1000, epsilon_small_factor=1):
        r"""__init__(EMDFloat64 self, double R=1, double beta=1, bool norm=False, bool do_timing=False, bool external_dists=False, std::size_t n_iter_max=100000, double epsilon_large_factor=1000, double epsilon_small_factor=1) -> EMDFloat64"""
        _wasserstein.EMDFloat64_swiginit(self, _wasserstein.new_EMDFloat64(R, beta, norm, do_timing, external_dists, n_iter_max, epsilon_large_factor, epsilon_small_factor))
    __swig_destroy__ = _wasserstein.delete_EMDFloat64

    def description(self, write_preprocessors=True):
        r"""description(EMDFloat64 self, bool write_preprocessors=True) -> std::string"""
        return _wasserstein.EMDFloat64_description(self, write_preprocessors)

    def __repr__(self):
        r"""__repr__(EMDFloat64 self) -> std::string"""
        return _wasserstein.EMDFloat64___repr__(self)

    def preprocess_CenterWeightedCentroid(self):
        r"""preprocess_CenterWeightedCentroid(EMDFloat64 self)"""
        return _wasserstein.EMDFloat64_preprocess_CenterWeightedCentroid(self)

    def __call__(self, *args):
        r"""
        __call__(EMDFloat64 self, double * weights0, double * coords0, double * weights1, double * coords1) -> double
        __call__(EMDFloat64 self, double * weights0, double * weights1, double * external_dists) -> double
        """
        return _wasserstein.EMDFloat64___call__(self, *args)

# Register EMDFloat64 in _wasserstein:
_wasserstein.EMDFloat64_swigregister(EMDFloat64)
class EMDFloat32(EMDBaseFloat32):
    r"""Proxy of C++ wasserstein::EMD< float,wasserstein::DefaultArrayEvent,wasserstein::EuclideanArrayDistance > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, R=1, beta=1, norm=False, do_timing=False, external_dists=False, n_iter_max=100000, epsilon_large_factor=1000, epsilon_small_factor=1):
        r"""__init__(EMDFloat32 self, float R=1, float beta=1, bool norm=False, bool do_timing=False, bool external_dists=False, std::size_t n_iter_max=100000, float epsilon_large_factor=1000, float epsilon_small_factor=1) -> EMDFloat32"""
        _wasserstein.EMDFloat32_swiginit(self, _wasserstein.new_EMDFloat32(R, beta, norm, do_timing, external_dists, n_iter_max, epsilon_large_factor, epsilon_small_factor))
    __swig_destroy__ = _wasserstein.delete_EMDFloat32

    def description(self, write_preprocessors=True):
        r"""description(EMDFloat32 self, bool write_preprocessors=True) -> std::string"""
        return _wasserstein.EMDFloat32_description(self, write_preprocessors)

    def __repr__(self):
        r"""__repr__(EMDFloat32 self) -> std::string"""
        return _wasserstein.EMDFloat32___repr__(self)

    def preprocess_CenterWeightedCentroid(self):
        r"""preprocess_CenterWeightedCentroid(EMDFloat32 self)"""
        return _wasserstein.EMDFloat32_preprocess_CenterWeightedCentroid(self)

    def __call__(self, *args):
        r"""
        __call__(EMDFloat32 self, float * weights0, float * coords0, float * weights1, float * coords1) -> float
        __call__(EMDFloat32 self, float * weights0, float * weights1, float * external_dists) -> float
        """
        return _wasserstein.EMDFloat32___call__(self, *args)

# Register EMDFloat32 in _wasserstein:
_wasserstein.EMDFloat32_swigregister(EMDFloat32)
class EMDYPhiFloat64(EMDBaseFloat64):
    r"""Proxy of C++ wasserstein::EMD< double,wasserstein::DefaultArray2Event,wasserstein::YPhiArrayDistance > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, R=1, beta=1, norm=False, do_timing=False, external_dists=False, n_iter_max=100000, epsilon_large_factor=1000, epsilon_small_factor=1):
        r"""__init__(EMDYPhiFloat64 self, double R=1, double beta=1, bool norm=False, bool do_timing=False, bool external_dists=False, std::size_t n_iter_max=100000, double epsilon_large_factor=1000, double epsilon_small_factor=1) -> EMDYPhiFloat64"""
        _wasserstein.EMDYPhiFloat64_swiginit(self, _wasserstein.new_EMDYPhiFloat64(R, beta, norm, do_timing, external_dists, n_iter_max, epsilon_large_factor, epsilon_small_factor))
    __swig_destroy__ = _wasserstein.delete_EMDYPhiFloat64

    def description(self, write_preprocessors=True):
        r"""description(EMDYPhiFloat64 self, bool write_preprocessors=True) -> std::string"""
        return _wasserstein.EMDYPhiFloat64_description(self, write_preprocessors)

    def __repr__(self):
        r"""__repr__(EMDYPhiFloat64 self) -> std::string"""
        return _wasserstein.EMDYPhiFloat64___repr__(self)

    def preprocess_CenterWeightedCentroid(self):
        r"""preprocess_CenterWeightedCentroid(EMDYPhiFloat64 self)"""
        return _wasserstein.EMDYPhiFloat64_preprocess_CenterWeightedCentroid(self)

    def __call__(self, *args):
        r"""
        __call__(EMDYPhiFloat64 self, double * weights0, double * coords0, double * weights1, double * coords1) -> double
        __call__(EMDYPhiFloat64 self, double * weights0, double * weights1, double * external_dists) -> double
        """
        return _wasserstein.EMDYPhiFloat64___call__(self, *args)

# Register EMDYPhiFloat64 in _wasserstein:
_wasserstein.EMDYPhiFloat64_swigregister(EMDYPhiFloat64)
class EMDYPhiFloat32(EMDBaseFloat32):
    r"""Proxy of C++ wasserstein::EMD< float,wasserstein::DefaultArray2Event,wasserstein::YPhiArrayDistance > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, R=1, beta=1, norm=False, do_timing=False, external_dists=False, n_iter_max=100000, epsilon_large_factor=1000, epsilon_small_factor=1):
        r"""__init__(EMDYPhiFloat32 self, float R=1, float beta=1, bool norm=False, bool do_timing=False, bool external_dists=False, std::size_t n_iter_max=100000, float epsilon_large_factor=1000, float epsilon_small_factor=1) -> EMDYPhiFloat32"""
        _wasserstein.EMDYPhiFloat32_swiginit(self, _wasserstein.new_EMDYPhiFloat32(R, beta, norm, do_timing, external_dists, n_iter_max, epsilon_large_factor, epsilon_small_factor))
    __swig_destroy__ = _wasserstein.delete_EMDYPhiFloat32

    def description(self, write_preprocessors=True):
        r"""description(EMDYPhiFloat32 self, bool write_preprocessors=True) -> std::string"""
        return _wasserstein.EMDYPhiFloat32_description(self, write_preprocessors)

    def __repr__(self):
        r"""__repr__(EMDYPhiFloat32 self) -> std::string"""
        return _wasserstein.EMDYPhiFloat32___repr__(self)

    def preprocess_CenterWeightedCentroid(self):
        r"""preprocess_CenterWeightedCentroid(EMDYPhiFloat32 self)"""
        return _wasserstein.EMDYPhiFloat32_preprocess_CenterWeightedCentroid(self)

    def __call__(self, *args):
        r"""
        __call__(EMDYPhiFloat32 self, float * weights0, float * coords0, float * weights1, float * coords1) -> float
        __call__(EMDYPhiFloat32 self, float * weights0, float * weights1, float * external_dists) -> float
        """
        return _wasserstein.EMDYPhiFloat32___call__(self, *args)

# Register EMDYPhiFloat32 in _wasserstein:
_wasserstein.EMDYPhiFloat32_swigregister(EMDYPhiFloat32)
class PairwiseEMDFloat64(PairwiseEMDBaseFloat64):
    r"""Proxy of C++ wasserstein::PairwiseEMD< wasserstein::EMD< double,wasserstein::DefaultArrayEvent,wasserstein::EuclideanArrayDistance >,double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _wasserstein.delete_PairwiseEMDFloat64

    def description(self):
        r"""description(PairwiseEMDFloat64 self) -> std::string"""
        return _wasserstein.PairwiseEMDFloat64_description(self)

    def clear(self, *args, **kwargs):
        _wasserstein.PairwiseEMDFloat64_clear(self, *args, **kwargs)
        if hasattr(self, 'event_arrs'):
            del self.event_arrs



    def init(self, *args):
        r"""
        init(PairwiseEMDFloat64 self, wasserstein::index_type nev)
        init(PairwiseEMDFloat64 self, wasserstein::index_type nevA, wasserstein::index_type nevB)
        """
        return _wasserstein.PairwiseEMDFloat64_init(self, *args)

    def compute(self):
        r"""compute(PairwiseEMDFloat64 self)"""
        return _wasserstein.PairwiseEMDFloat64_compute(self)

    def __repr__(self):
        r"""__repr__(PairwiseEMDFloat64 self) -> std::string"""
        return _wasserstein.PairwiseEMDFloat64___repr__(self)

    def preprocess_CenterWeightedCentroid(self):
        r"""preprocess_CenterWeightedCentroid(PairwiseEMDFloat64 self)"""
        return _wasserstein.PairwiseEMDFloat64_preprocess_CenterWeightedCentroid(self)

    def _reset_B_events(self):
        r"""_reset_B_events(PairwiseEMDFloat64 self)"""
        return _wasserstein.PairwiseEMDFloat64__reset_B_events(self)


    def set_new_eventsB(self, eventsB, gdim=None, mask=False, event_weightsB=None):

    # check that we have been initialized before
        if not hasattr(self, 'event_arrs'):
            raise RuntimeError('PairwiseEMD object must be called on some events before the B events can be reset')

    # check that we are in request mode
        if not self.request_mode():
            raise RuntimeError('PairwiseEMD object must be in request mode in order to set new eventsB')

        if event_weightsB is None:
            event_weightsB = np.ones(len(eventsB))
        elif len(event_weightsB) != len(eventsB):
            raise ValueError('length of `event_weightsB` does not match length of `eventsB`')

    # clear away old B events in underlying object
        self._reset_B_events()

    # clear B events from python array
        del self.event_arrs[self.nevA():]

    # reinitialize
        self.init(self.nevA(), len(eventsB))
        _store_events(self, eventsB, event_weightsB, gdim, mask, self._float_dtype)


    def _add_event(self, weights, coords, event_weight=1):
        r"""_add_event(PairwiseEMDFloat64 self, double * weights, double * coords, double event_weight=1)"""
        return _wasserstein.PairwiseEMDFloat64__add_event(self, weights, coords, event_weight)

# Register PairwiseEMDFloat64 in _wasserstein:
_wasserstein.PairwiseEMDFloat64_swigregister(PairwiseEMDFloat64)
class PairwiseEMDFloat32(PairwiseEMDBaseFloat32):
    r"""Proxy of C++ wasserstein::PairwiseEMD< wasserstein::EMD< float,wasserstein::DefaultArrayEvent,wasserstein::EuclideanArrayDistance >,float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _wasserstein.delete_PairwiseEMDFloat32

    def description(self):
        r"""description(PairwiseEMDFloat32 self) -> std::string"""
        return _wasserstein.PairwiseEMDFloat32_description(self)

    def clear(self, *args, **kwargs):
        _wasserstein.PairwiseEMDFloat32_clear(self, *args, **kwargs)
        if hasattr(self, 'event_arrs'):
            del self.event_arrs



    def init(self, *args):
        r"""
        init(PairwiseEMDFloat32 self, wasserstein::index_type nev)
        init(PairwiseEMDFloat32 self, wasserstein::index_type nevA, wasserstein::index_type nevB)
        """
        return _wasserstein.PairwiseEMDFloat32_init(self, *args)

    def compute(self):
        r"""compute(PairwiseEMDFloat32 self)"""
        return _wasserstein.PairwiseEMDFloat32_compute(self)

    def __repr__(self):
        r"""__repr__(PairwiseEMDFloat32 self) -> std::string"""
        return _wasserstein.PairwiseEMDFloat32___repr__(self)

    def preprocess_CenterWeightedCentroid(self):
        r"""preprocess_CenterWeightedCentroid(PairwiseEMDFloat32 self)"""
        return _wasserstein.PairwiseEMDFloat32_preprocess_CenterWeightedCentroid(self)

    def _reset_B_events(self):
        r"""_reset_B_events(PairwiseEMDFloat32 self)"""
        return _wasserstein.PairwiseEMDFloat32__reset_B_events(self)


    def set_new_eventsB(self, eventsB, gdim=None, mask=False, event_weightsB=None):

    # check that we have been initialized before
        if not hasattr(self, 'event_arrs'):
            raise RuntimeError('PairwiseEMD object must be called on some events before the B events can be reset')

    # check that we are in request mode
        if not self.request_mode():
            raise RuntimeError('PairwiseEMD object must be in request mode in order to set new eventsB')

        if event_weightsB is None:
            event_weightsB = np.ones(len(eventsB))
        elif len(event_weightsB) != len(eventsB):
            raise ValueError('length of `event_weightsB` does not match length of `eventsB`')

    # clear away old B events in underlying object
        self._reset_B_events()

    # clear B events from python array
        del self.event_arrs[self.nevA():]

    # reinitialize
        self.init(self.nevA(), len(eventsB))
        _store_events(self, eventsB, event_weightsB, gdim, mask, self._float_dtype)


    def _add_event(self, weights, coords, event_weight=1):
        r"""_add_event(PairwiseEMDFloat32 self, float * weights, float * coords, float event_weight=1)"""
        return _wasserstein.PairwiseEMDFloat32__add_event(self, weights, coords, event_weight)

# Register PairwiseEMDFloat32 in _wasserstein:
_wasserstein.PairwiseEMDFloat32_swigregister(PairwiseEMDFloat32)
class PairwiseEMDYPhiFloat64(PairwiseEMDBaseFloat64):
    r"""Proxy of C++ wasserstein::PairwiseEMD< wasserstein::EMD< double,wasserstein::DefaultArray2Event,wasserstein::YPhiArrayDistance >,double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _wasserstein.delete_PairwiseEMDYPhiFloat64

    def description(self):
        r"""description(PairwiseEMDYPhiFloat64 self) -> std::string"""
        return _wasserstein.PairwiseEMDYPhiFloat64_description(self)

    def clear(self, *args, **kwargs):
        _wasserstein.PairwiseEMDYPhiFloat64_clear(self, *args, **kwargs)
        if hasattr(self, 'event_arrs'):
            del self.event_arrs



    def init(self, *args):
        r"""
        init(PairwiseEMDYPhiFloat64 self, wasserstein::index_type nev)
        init(PairwiseEMDYPhiFloat64 self, wasserstein::index_type nevA, wasserstein::index_type nevB)
        """
        return _wasserstein.PairwiseEMDYPhiFloat64_init(self, *args)

    def compute(self):
        r"""compute(PairwiseEMDYPhiFloat64 self)"""
        return _wasserstein.PairwiseEMDYPhiFloat64_compute(self)

    def __repr__(self):
        r"""__repr__(PairwiseEMDYPhiFloat64 self) -> std::string"""
        return _wasserstein.PairwiseEMDYPhiFloat64___repr__(self)

    def preprocess_CenterWeightedCentroid(self):
        r"""preprocess_CenterWeightedCentroid(PairwiseEMDYPhiFloat64 self)"""
        return _wasserstein.PairwiseEMDYPhiFloat64_preprocess_CenterWeightedCentroid(self)

    def _reset_B_events(self):
        r"""_reset_B_events(PairwiseEMDYPhiFloat64 self)"""
        return _wasserstein.PairwiseEMDYPhiFloat64__reset_B_events(self)


    def set_new_eventsB(self, eventsB, gdim=None, mask=False, event_weightsB=None):

    # check that we have been initialized before
        if not hasattr(self, 'event_arrs'):
            raise RuntimeError('PairwiseEMD object must be called on some events before the B events can be reset')

    # check that we are in request mode
        if not self.request_mode():
            raise RuntimeError('PairwiseEMD object must be in request mode in order to set new eventsB')

        if event_weightsB is None:
            event_weightsB = np.ones(len(eventsB))
        elif len(event_weightsB) != len(eventsB):
            raise ValueError('length of `event_weightsB` does not match length of `eventsB`')

    # clear away old B events in underlying object
        self._reset_B_events()

    # clear B events from python array
        del self.event_arrs[self.nevA():]

    # reinitialize
        self.init(self.nevA(), len(eventsB))
        _store_events(self, eventsB, event_weightsB, gdim, mask, self._float_dtype)


    def _add_event(self, weights, coords, event_weight=1):
        r"""_add_event(PairwiseEMDYPhiFloat64 self, double * weights, double * coords, double event_weight=1)"""
        return _wasserstein.PairwiseEMDYPhiFloat64__add_event(self, weights, coords, event_weight)

# Register PairwiseEMDYPhiFloat64 in _wasserstein:
_wasserstein.PairwiseEMDYPhiFloat64_swigregister(PairwiseEMDYPhiFloat64)
class PairwiseEMDYPhiFloat32(PairwiseEMDBaseFloat32):
    r"""Proxy of C++ wasserstein::PairwiseEMD< wasserstein::EMD< float,wasserstein::DefaultArray2Event,wasserstein::YPhiArrayDistance >,float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _wasserstein.delete_PairwiseEMDYPhiFloat32

    def description(self):
        r"""description(PairwiseEMDYPhiFloat32 self) -> std::string"""
        return _wasserstein.PairwiseEMDYPhiFloat32_description(self)

    def clear(self, *args, **kwargs):
        _wasserstein.PairwiseEMDYPhiFloat32_clear(self, *args, **kwargs)
        if hasattr(self, 'event_arrs'):
            del self.event_arrs



    def init(self, *args):
        r"""
        init(PairwiseEMDYPhiFloat32 self, wasserstein::index_type nev)
        init(PairwiseEMDYPhiFloat32 self, wasserstein::index_type nevA, wasserstein::index_type nevB)
        """
        return _wasserstein.PairwiseEMDYPhiFloat32_init(self, *args)

    def compute(self):
        r"""compute(PairwiseEMDYPhiFloat32 self)"""
        return _wasserstein.PairwiseEMDYPhiFloat32_compute(self)

    def __repr__(self):
        r"""__repr__(PairwiseEMDYPhiFloat32 self) -> std::string"""
        return _wasserstein.PairwiseEMDYPhiFloat32___repr__(self)

    def preprocess_CenterWeightedCentroid(self):
        r"""preprocess_CenterWeightedCentroid(PairwiseEMDYPhiFloat32 self)"""
        return _wasserstein.PairwiseEMDYPhiFloat32_preprocess_CenterWeightedCentroid(self)

    def _reset_B_events(self):
        r"""_reset_B_events(PairwiseEMDYPhiFloat32 self)"""
        return _wasserstein.PairwiseEMDYPhiFloat32__reset_B_events(self)


    def set_new_eventsB(self, eventsB, gdim=None, mask=False, event_weightsB=None):

    # check that we have been initialized before
        if not hasattr(self, 'event_arrs'):
            raise RuntimeError('PairwiseEMD object must be called on some events before the B events can be reset')

    # check that we are in request mode
        if not self.request_mode():
            raise RuntimeError('PairwiseEMD object must be in request mode in order to set new eventsB')

        if event_weightsB is None:
            event_weightsB = np.ones(len(eventsB))
        elif len(event_weightsB) != len(eventsB):
            raise ValueError('length of `event_weightsB` does not match length of `eventsB`')

    # clear away old B events in underlying object
        self._reset_B_events()

    # clear B events from python array
        del self.event_arrs[self.nevA():]

    # reinitialize
        self.init(self.nevA(), len(eventsB))
        _store_events(self, eventsB, event_weightsB, gdim, mask, self._float_dtype)


    def _add_event(self, weights, coords, event_weight=1):
        r"""_add_event(PairwiseEMDYPhiFloat32 self, float * weights, float * coords, float event_weight=1)"""
        return _wasserstein.PairwiseEMDYPhiFloat32__add_event(self, weights, coords, event_weight)

# Register PairwiseEMDYPhiFloat32 in _wasserstein:
_wasserstein.PairwiseEMDYPhiFloat32_swigregister(PairwiseEMDYPhiFloat32)

def EMD(*args, **kwargs):
    dtype = kwargs.pop('dtype', 'float64')
    if dtype == 'float64' or dtype == np.float64:
        return EMDFloat64(*args, **kwargs)
    elif dtype == 'float32' or dtype == np.float32:
        return EMDFloat32(*args, **kwargs)
    else:
      raise TypeError('`dtype` {} not supported'.format(dtype))


def EMDYPhi(*args, **kwargs):
    dtype = kwargs.pop('dtype', 'float64')
    if dtype == 'float64' or dtype == np.float64:
        return EMDYPhiFloat64(*args, **kwargs)
    elif dtype == 'float32' or dtype == np.float32:
        return EMDYPhiFloat32(*args, **kwargs)
    else:
      raise TypeError('`dtype` {} not supported'.format(dtype))


def PairwiseEMD(*args, **kwargs):
    dtype = kwargs.pop('dtype', 'float64')
    if dtype == 'float64' or dtype == np.float64:
        return PairwiseEMDFloat64(*args, **kwargs)
    elif dtype == 'float32' or dtype == np.float32:
        return PairwiseEMDFloat32(*args, **kwargs)
    else:
      raise TypeError('`dtype` {} not supported'.format(dtype))


def PairwiseEMDYPhi(*args, **kwargs):
    dtype = kwargs.pop('dtype', 'float64')
    if dtype == 'float64' or dtype == np.float64:
        return PairwiseEMDYPhiFloat64(*args, **kwargs)
    elif dtype == 'float32' or dtype == np.float32:
        return PairwiseEMDYPhiFloat32(*args, **kwargs)
    else:
      raise TypeError('`dtype` {} not supported'.format(dtype))
